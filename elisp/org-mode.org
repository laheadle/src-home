#+TITLE: Org Mode - Organize Your Life In Plain Text!
#+LANGUAGE:  en
#+AUTHOR: Bernt Hansen (IRC: BerntH on freenode)
#+EMAIL: bernt@norang.ca
#+OPTIONS:   H:3 num:t   toc:3 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:nil
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:   author:t creator:t timestamp:t email:t
#+DESCRIPTION: A description of how I currently use org-mode
#+KEYWORDS:  org-mode Emacs organization GTD getting-things-done git
#+SEQ_TODO: FIXME FIXED
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

Org-mode is a fabulous organizational tool originally built by Carsten
Dominik that operates on plain text files.  Org-mode is part of Emacs.

* License
:PROPERTIES:
:CUSTOM_ID: License
:END:
[2011-11-19 Sat 21:53] 

#+begin_example
Copyright (C)  2013  Bernt Hansen.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
  
Code in this document is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation, either
version 3 of the License, or (at your option) any later version.
  
This code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#+end_example

This document http://doc.norang.ca/org-mode.html (either in its
[[http://doc.norang.ca/org-mode.html][HTML format]] or in its [[http://doc.norang.ca/org-mode.org][Org format]]) is licensed under the GNU Free
Documentation License version 1.3 or later
(http://www.gnu.org/copyleft/fdl.html).

The code examples and CSS stylesheets are licensed under the GNU
General Public License v3 or later
(http://www.gnu.org/licenses/gpl.html).
* Getting Started
:PROPERTIES:
:CUSTOM_ID: GettingStarted
:END:

Getting started with =org-mode= is really easy.  You only need a few lines in your
emacs startup to use the latest version of org-mode from the =git= repository.
** Getting org-mode with Git
:PROPERTIES:
:CUSTOM_ID: GettingOrgModeWithGit
:END:
[2012-06-24 Sun 11:21]

I keep a copy of the org-mode =git= repository in =~/extern/org-mode/=.  This clone
was created with
#+begin_src sh
cd ~/git
git clone git://orgmode.org/org-mode.git
#+end_src

To update and get new commits from the org-mode developers you can use 
#+begin_src sh
cd ~/extern/org-mode
git pull
make uncompiled
#+end_src

I run uncompiled source files in my setup so the uncompiled =make= target is all you need.

I normally track the =master= branch in the org-mode repository.
** Org-Mode Setup
:PROPERTIES:
:CUSTOM_ID: Setup
:END:

The following setup in my .emacs enables =org-mode= for most buffers.
=org-mode= is the default mode for =.org=, =.org_archive=, and =.txt=
files.

#+header: :tangle yes
#+begin_src emacs-lisp :exports none
;; The following setting is different from the document so that you
;; can override the document path by setting your path in the variable
;; org-mode-user-lisp-path
;;

(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
(require 'org)
;(org-reload t)
;;
;; Standard key bindings
(global-set-key "\C-cl" 'org-store-link)
#+end_src

That's all you need to get started using headlines and lists in org-mode.

The rest of this document describes customizations I use in my setup,
how I structure org-mode files, and other changes to fit the way I
want org-mode to work.
** Org File Structure
:PROPERTIES:
:CUSTOM_ID: OrgFileStructure
:END:

Most of my org files are set up with level 1 headings as main
categories only.  Tasks and projects normally start as level 2.

Here are some examples of my level 1 headings in

=todo.org=:

- Special Dates

  Includes level 2 headings for

  - Birthdays
  - Anniversaries
  - Holidays

- Finances
- Health and Recreation
- House Maintenance
- Lawn and Garden Maintenance
- Notes
- Tasks
- Vehicle Maintenance
- Passwords


=norang.org=:

- System Maintenance
- Payroll
- Accounting
- Finances
- Hardware Maintenance
- Tasks
- Research and Development
- Notes
- Purchase Order Tracking
- Passwords

Each of these level 1 tasks normally has a =property drawer=
specifying the category for any tasks in that tree.  Level 1 headings
are set up like this:

#+begin_src org :exports src
,* Health and Recreation
  :PROPERTIES:
  :CATEGORY: Health
  :END:
  ...
,* House Maintenance
  :PROPERTIES:
  :CATEGORY: House
  :END:
#+end_src
** Key bindings
:PROPERTIES:
:CUSTOM_ID: KeyBindings
:END:

Here is the keybinding setup in lisp:
#+header: :tangle yes
#+begin_src emacs-lisp
;; Custom Key Bindings


(bind-key "C-\\" 'org-agenda)
(bind-key "C-!" 'org-cycle-agenda-files)
(bind-key "M-c" 'my-map)

(bind-key "M-c c" 'calendar)
(bind-key "M-c f" 'boxquote-insert-file)

(bind-key "M-c I" 'bh/punch-in)
(bind-key "M-c O" 'bh/punch-out)

(bind-key "M-c SPC" 'bh/clock-in-last-task)
(bind-key "C-<" 'previous-buffer)
(bind-key "C->" 'next-buffer)
(bind-key "M-[" 'org-clock-goto)
(global-set-key (kbd "C-c c") 'org-capture)
(bind-key "C-)" 'l-org-refresh-refiles)


#+end_src

* Tasks and States
:PROPERTIES:
:CUSTOM_ID: TasksAndStates
:END:

I use one set of TODO keywords for all of my org files.  Org-mode lets
you define TODO keywords per file but I find it's easier to have a
standard set of TODO keywords globally so I can use the same setup in
any org file I'm working with.

The only exception to this is this document :) since I don't want
=org-mode= hiding the =TODO= keyword when it appears in headlines.
I've set up a dummy =#+SEQ_TODO: FIXME FIXED= entry at the top of this
file just to leave my =TODO= keyword untouched in this document.
** TODO keywords
:PROPERTIES:
:CUSTOM_ID: TodoKeywords
:END:

I use a light colour theme in emacs.  I find this easier to read on bright sunny days.

Here are my =TODO= state keywords and colour settings:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote (
              (sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")
              (sequence "GOAL(g)" "|"))))

(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)
              ("MEETING" :foreground "forest green" :weight bold)
              ("PHONE" :foreground "forest green" :weight bold))))
#+end_src
*** Task States
:PROPERTIES:
:CUSTOM_ID: TodoKeywordTaskStates
:END:

Tasks go through the sequence =TODO= -> =DONE=.

The following diagram shows the possible state transitions for a task.

#+begin_src plantuml :file normal_task_states.png :cache yes
title Task States
[*] -> TODO
TODO -> NEXT
TODO -> DONE
NEXT -> DONE
DONE -> [*]
TODO --> WAITING
WAITING --> TODO
NEXT --> WAITING
WAITING --> NEXT
HOLD --> CANCELLED
WAITING --> CANCELLED
CANCELLED --> [*]
TODO --> HOLD
HOLD --> TODO
TODO --> CANCELLED
TODO: t
NEXT: n
DONE: d
WAITING:w
note right of WAITING: Note records\nwhat it is waiting for
HOLD:h
note right of CANCELLED: Note records\nwhy it was cancelled
CANCELLED:c
WAITING --> DONE
#+end_src

#+results[61c867b8eb4f49bc47e44ec2b534ac3219d82594]:
[[file:normal_task_states.png]]

*** Meetings
:PROPERTIES:
:CUSTOM_ID: TodoKeywordMeetings
:END:

Meetings are special.  They are created in a done state by a capture
task.  I use the MEETING capture template when someone interrupts what
I'm doing with a question or discussion.  This is handled similarly to
phone calls where I clock the amount of time spent with whomever it is
and record some notes of what was discussed (either during or after
the meeting) depending on content, length, and complexity of the
discussion.

The time of the meeting is recorded for as long as the capture task is
active.  If I need to look up other details and want to close the
capture task early I can just =C-c C-c= to close the capture task
(stopping the clock) and then =f9 SPC= to resume the clock in the
meeting task while I do other things.
#+begin_src plantuml :file meeting_states.png :cache yes
title Meeting Task State
[*] -> MEETING
MEETING -> [*]
#+end_src

#+results[942fb408787905ffcdde421ee02edabdbb921b06]:
[[file:meeting_states.png]]

** Fast Todo Selection
:PROPERTIES:
:CUSTOM_ID: FastTodoSelection
:END:

Fast todo selection allows changing from any task todo state to any
other state directly by selecting the appropriate key from the fast
todo selection key menu.  This is a great feature!

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-use-fast-todo-selection t)
#+end_src

Changing a task state is done with =C-c C-t KEY=

where =KEY= is the appropriate fast todo state selection key as defined in =org-todo-keywords=.

The setting
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src
allows changing todo states with S-left and S-right skipping all of
the normal processing when entering or leaving a todo state.  This
cycles through the todo states but skips setting timestamps and
entering notes which is very convenient when all you want to do is fix
up the status of an entry.
** TODO state triggers
:PROPERTIES:
:CUSTOM_ID: ToDoStateTriggers
:END:

I have a few triggers that automatically assign tags to tasks based on
state changes.  If a task moves to =CANCELLED= state then it gets a
=CANCELLED= tag.  Moving a =CANCELLED= task back to =TODO= removes the
=CANCELLED= tag.  These are used for filtering tasks in agenda views
which I'll talk about later.

The triggers break down to the following rules:

- Moving a task to =CANCELLED= adds a =CANCELLED= tag
- Moving a task to =WAITING= adds a =WAITING= tag
- Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
- Moving a task to a done state removes =WAITING= and =HOLD= tags
- Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags

The tags are used to filter tasks in the agenda views conveniently.

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING") ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+end_src
* Adding New Tasks Quickly with Org Capture
:PROPERTIES:
:CUSTOM_ID: Capture
:END:

Org Capture mode replaces remember mode for capturing tasks and notes.

To add new tasks efficiently I use a minimal number of capture
templates.  I used to have lots of capture templates, one for each
org-file.  I'd start org-capture with =C-c c= and then pick a template
that filed the task under =* Tasks= in the appropriate file.

I found I still needed to refile these capture tasks again to the
correct location within the org-file so all of these different capture
templates weren't really helping at all.  Since then I've changed my
workflow to use a minimal number of capture templates -- I create the
new task quickly and refile it once.  This also saves me from
maintaining my org-capture templates when I add a new org file.
** Capture Templates
:PROPERTIES:
:CUSTOM_ID: CaptureTemplates
:END:

When a new task needs to be added I categorize it into one of a few
things:

- A phone call (p)
- A meeting (m)
- An email I need to respond to (r)
- A new task (t)
- A new note (n)
- An interruption (j)
- A new habit (h)

and pick the appropriate capture task.

Here is my setup for org-capture

#+header: :tangle yes
#+begin_src emacs-lisp

;; I use C-c c to start capture mode
(global-set-key (kbd "C-c c") 'org-capture)

#+end_src

Capture mode now handles automatically clocking in and out of a
capture task.  This all works out of the box now without special hooks.
When I start a capture mode task the task is clocked in as specified
by =:clock-in t= and when the task is filed with =C-c C-c= the clock 
resumes on the original clocking task.

The quick clocking in and out of capture mode tasks (often it takes
less than a minute to capture some new task details) can leave
empty clock drawers in my tasks which aren't really useful.  Since I
remove clocking lines with 0:00 length I end up with a clock drawer
like this:

#+begin_src org :exports src
,* TODO New Capture Task
  :LOGBOOK:
  :END:
  [2010-05-08 Sat 13:53]
#+end_src
I have the following setup to remove these empty =LOGBOOK= drawers if
they occur.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)

#+end_src

** Separate file for Capture Tasks
:PROPERTIES:
:CUSTOM_ID: CaptureRefileOrg
:END:

I have a single org file which is the target for my capture templates.

I store notes, tasks, phone calls, and org-protocol tasks in
=refile.org=.  I used to use multiple files but found that didn't
really have any advantage over a single file.

Normally this file is empty except for a single line at the top which
creates a =REFILE= tag for anything in the file.

The file has a single permanent line at the top like this
#+begin_src org :exports src
,#+FILETAGS: REFILE
#+end_src
** Capture Tasks is all about being FAST
:PROPERTIES:
:CUSTOM_ID: CaptureTasksAreFast
:END:

Okay I'm in the middle of something and oh yeah - I have to remember
to do that.  I don't stop what I'm doing.  I'm probably clocking a
project I'm working on and I don't want to lose my focus on that but I
can't afford to forget this little thing that just came up.

So what do I do?  Hit =C-c c= to start capture mode and select =t=
since it's a new task and I get a buffer like this:

#+begin_src org :exports src
,* TODO 
  [2010-08-05 Thu 21:06]

  [[file:~/extern/org-mode-doc/org-mode.org::*Capture%20Tasks%20is%20all%20about%20being%20FAST][Capture Tasks is all about being FAST]]
#+end_src

Enter the details of the TODO item and =C-c C-c= to file it away in
refile.org and go right back to what I'm really working on secure in
the knowledge that that item isn't going to get lost and I don't have
to think about it anymore at all now.

The amount of time I spend entering the captured note is clocked.  The
capture templates are set to automatically clock in and out of the
capture task.  This is great for interruptions and telephone calls
too.
* Refiling Tasks
:PROPERTIES:
:CUSTOM_ID: Refiling
:END:

Refiling tasks is easy.  After collecting a bunch of new tasks in my
refile.org file using capture mode I need to move these to the
correct org file and topic.  All of my active org-files are in my
=org-agenda-files= variable and contribute to the agenda.

I collect capture tasks in refile.org for up to a week.  These now
stand out daily on my block agenda and I usually refile them during
the day.  I like to keep my refile task list empty.
** Refile Setup
:PROPERTIES:
:CUSTOM_ID: RefileSetup
:END:

To refile tasks in org you need to tell it where you want to refile things.

In my setup I let any file in =org-agenda-files= and the current file
contribute to the list of valid refile targets.  

I've recently moved to using IDO to complete targets directly.  I find
this to be faster than my previous complete in steps setup.  At first
I didn't like IDO but after reviewing the documentation again and
learning about =C-SPC= to limit target searches I find it is much
better than my previous complete-in-steps setup.  Now when I want to
refile something I do =C-c C-w= to start the refile process, then type
something to get some matching targets, then =C-SPC= to restrict the
matches to the current list, then continue searching with some other
text to find the target I need.  =C-j= also selects the current
completion as the final target.  I like this a lot.  I show full
outline paths in the targets so I can have the same heading in
multiple subtrees or projects and still tell them apart while
refiling.

I now exclude =DONE= state tasks as valid refile targets.  This helps to keep the
refile target list to a reasonable size.

Here is my refile configuration:
#+header: :tangle yes
#+begin_src emacs-lisp
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil   ; current buffer
                                  :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))

; Use full outline paths for refile targets - we file directly with IDO
(setq org-refile-use-outline-path t)

; Targets complete directly with IDO
(setq org-outline-path-complete-in-steps nil)

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

; Use IDO for both buffer and file completion and ido-everywhere to t
(setq org-completion-use-ido t)
(setq ido-everywhere t)
(setq ido-max-directory-size 100000)
(ido-mode (quote both))
; Use the current window when visiting files and buffers with ido
(setq ido-default-file-method 'selected-window)
(setq ido-default-buffer-method 'selected-window)
; Use the current window for indirect buffer display
(setq org-indirect-buffer-display 'current-window)

;;;; Refile settings
; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src

To refile a task to my =norang.org= file under =System Maintenance= I
just put the cursor on the task and hit =C-c C-w= and enter =nor C-SPC
sys RET= and it's done.  IDO completion makes locating targets a snap.
** Refiling Tasks
:PROPERTIES:
:CUSTOM_ID: RefilingTasks
:END:

Tasks to refile are in their own section of the block agenda.  To find
tasks to refile I run my agenda view with =F12 SPC= and scroll down to
second section of the block agenda: =Tasks to Refile=.  This view
shows all tasks (even ones marked in a =done= state).

Bulk refiling in the agenda works very well for multiple tasks going
to the same place.  Just mark the tasks with =m= and then =B r= to
refile all of them to a new location.  Occasionally I'll also refile
tasks as subtasks of the current clocking task using =C-2 C-c C-w=
from the =refile.org= file.

Refiling all of my tasks tends to take less than a minute so I
normally do this a couple of times a day.
** Refiling Notes
:PROPERTIES:
:CUSTOM_ID: RefilingNotes
:END:

I keep a =* Notes= headline in most of my org-mode files.  Notes have
a =NOTE= tag which is created by the capture template for notes.  This
allows finding notes across multiple files easily using the agenda
search functions.

Notes created by capture tasks go first to =refile.org= and are later
refiled to the appropriate project file.  Some notes that are project
related get filed to the appropriate project instead of under the
catchall =* NOTES= task.  Generally these types of notes are specific
to the project and not generally useful -- so removing them from the
notes list when the project is archived makes sense.
** Refiling Phone Calls and Meetings
:PROPERTIES:
:CUSTOM_ID: RefilingPhoneCalls
:END:

Phone calls and meetings are handled using capture mode.  I time my
calls and meetings using the capture mode template settings to clock
in and out the capture task while the phone call or meeting is in
progress.

Phone call and meeting tasks collect in =refile.org= and are later
refiled to the appropriate location.  Some phone calls are billable
and we want these tracked in the appropriate category.  I refile my
phone call and meeting tasks under the appropriate project so time
tracking and reports are as accurate as possible.
* Custom agenda views
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViews
:END:

I now have one block agenda view that has everything on it.  I also
keep separate single view agenda commands for use on my slower Eee
PC - since it takes prohibitively long to generate my block agenda on
that slow machine.  I'm striving to simplify my layout with everything
at my fingertips in a single agenda on my workstation which is where I
spend the bulk of my time.

Most of my old custom agenda views were rendered obsolete when
filtering functionality was added to the agenda in newer versions of
=org-mode= and now with block agenda functionality I can combine
everything into a single view.

Custom agenda views are used for:
- Single block agenda shows the following
  - overview of today
  - Finding tasks to be refiled
  - Finding stuck projects
  - Finding NEXT tasks to work on
  - Show all related tasks
  - Reviewing projects
  - Finding tasks waiting on something
  - Findings tasks to be archived
- Finding notes
- Viewing habits

If I want just today's calendar view then =F12 a= is still faster than
generating the block agenda - especially if I want to view a week or
month's worth of information, or check my clocking data.  In that case
the extra detail on the block agenda view is never really needed and I
don't want to spend time waiting for it to be generated.
** Setup
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewSetup
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("g" "Goals"
               ((tags "TODO=\"GOAL\"" nil)
                (tags "GOALS-TODO=\"GOAL\""
                      ((org-tags-match-list-sublevels nil)))
                ))
              ("x" "Master Plan" 
               ((tags-todo "-DONE-CANCELLED-HOLD/!"
                           ((org-agenda-overriding-header "Priorities")
                            (org-agenda-todo-ignore-deadlines 'far)
                            (org-super-agenda-groups
                             '((:name "A" :priority "A" :order 300)
                               (:discard (:anything t))))))
                (agenda "" ((org-super-agenda-groups
                             '((:discard (:priority "A"))))))
                (tags-todo "-DONE-CANCELLED-HOLD/!"
                           ((org-agenda-overriding-header "Master Plan")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)
                            (org-super-agenda-groups
                             '((:todo "WAITING" :order 500)
                               (:name "B: This week" :priority "B" :order 400)
                               (:name "C: This month: Jan" :priority "C" :order 700)
                               (:name "D: This quarter: Q1" :priority "D" :order 800)
                               (:name "E: This half-year: Q1+Q2" :priority "E" :order 900)
                               (:name "F: This Year 2021" :priority "F" :order 1000)
                               (:name "G: These two Years: 2021-2" :priority "G" :order 1100)
                               (:discard (:anything t))))))
                (tags-todo "-DONE-CANCELLED-HOLD/!"
                           ((org-agenda-overriding-header "Far Deadliness")
                            (org-agenda-todo-ignore-deadlines 'near)
                            (org-agenda-todo-ignore-scheduled t)
                            (org-super-agenda-groups
                             '((:deadline t)
                               (:discard (:anything t))))))))
              ("zx" "Master Plan 2" 
               ((agenda "" nil)
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Week")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This week" :priority ("B"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Month")
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-deadlines t)
                            (org-agenda-todo-ignore-scheduled t)
                            (org-super-agenda-groups
                             '((:name "This month" :priority ("C"))
                               (:discard (:anything t))))))
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Quarter")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This quarter" :priority ("D"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Half-Year")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This half-year" :priority ("E"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Year")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This year" :priority ("F"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))
                (tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Year")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "These two years" :priority ("G"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("zw" "This Week" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Week")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This week" :priority ("A" "B"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("zm" "This Month" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Month")
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-deadlines t)
                            (org-agenda-todo-ignore-scheduled t)
                            (org-super-agenda-groups
                             '((:name "This month" :priority ("A" "B" "C"))
                               (:discard (:anything t))))))))
              ("zq" "This Quarter" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Quarter")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This quarter" :priority ("A" "B" "C" "D"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("zh" "This Half-year" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Half-Year")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This half-year" :priority ("A" "B" "C" "D" "E"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("zy" "This Year" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Year")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "This Year" :priority ("A" "B" "C" "D" "E" "F"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("zt" "The Next Two Years" 
               ((tags-todo "/!+TODO|+NEXT"
                           ((org-agenda-overriding-header "Two Years")
                            (org-agenda-todo-ignore-deadlines t)
                            (org-super-agenda-groups
                             '((:name "The Next Two Years" :priority ("A" "B" "C" "D" "E" "F" "G"))
                               (:discard (:anything t))))
                            (org-agenda-todo-ignore-with-date t)
                            (org-agenda-todo-ignore-scheduled t)))))
              ("za" "Archivable"
               ((agenda "" nil)
                (tags "-REFILE/"
                      ((org-agenda-overriding-header "Tasks to Archive")
                       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                       (org-tags-match-list-sublevels nil))))))))

#+end_src

My block agenda view looks like this when not narrowed to a project.
This shows top-level projects and =NEXT= tasks but hides the project details since
we are not focused on any particular project.

*NOTE:* This agenda screen shot is out of date and does not currently match the agenda setup in this document.
This will be fixed soon.

[[file:block-agenda-nonproject.png]]

After selecting a project (with =P= on any task in the agenda) the block agenda changes to show the project and
any subprojects in the Projects section.  Tasks show project-related tasks that are hidden when not
narrowed to a project.

This makes it easy to focus on the task at hand.

*NOTE:* This agenda screen shot is out of date and does not currently match the agenda setup in this document.
This will be fixed soon.


[[file:block-agenda-project.png]]

I generally work top-down on the agenda.  Things with deadlines and
scheduled dates (planned to work on today or earlier) show up in the
agenda at the top.

My day goes generally like this:

- Punch in (this starts the clock on the default task)
- Look at the agenda and make a mental note of anything important to deal with today
- Read email and news
  - create notes, and tasks for things that need responses with org-capture
- Check refile tasks and respond to emails
- Look at my agenda and work on important tasks for today
  - Clock it in
  - Work on it until it is =DONE= or it gets interrupted
- Work on tasks
- Make journal entries (=C-c c j=) for interruptions
- Punch out for lunch and punch back in after lunch
- work on more tasks
- Refile tasks to empty the list
  - Tag tasks to be refiled with =m= collecting all tasks for the same target
  - Bulk refile the tasks to the target location with =B r=
  - Repeat (or refile individually with =C-c C-w=) until all refile tasks are gone
- Mark habits done today as DONE
- Punch out at the end of the work day
** What do I work on next?
:PROPERTIES:
:CUSTOM_ID: WhatDoIWorkOnNext
:END:

Start with deadlines and tasks scheduled today or earlier from the
daily agenda view.  Then move on to tasks in the =Next Tasks= list in
the block agenda view.  I tend to schedule current projects to 'today'
when I start work on them and they sit on my daily agenda reminding me
that they need to be completed.  I normally only schedule one or two
projects to the daily agenda and unschedule things that are no longer
important and don't deserve my attention today.

When I look for a new task to work on I generally hit =F12 SPC= to get
the block agenda and follow this order:

- Pick something off today's agenda
  - deadline for today (do this first - it's not late yet)
  - deadline in the past (it's already late)
  - a scheduled task for today (it's supposed to be done today)
  - a scheduled task that is still on the agenda
  - deadline that is coming up soon
- pick a NEXT task
- If you run out of items to work on look for a NEXT task in the current context
  pick a task from the Tasks list of the current project.
*** Why keep it all on the =NEXT= list?
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewsNextList
:END:

I've moved to a more GTD way of doing things.  Now I just use a =NEXT=
list.  Only projects get tasks with =NEXT= keywords since stuck projects
initiate the need for marking or creating =NEXT= tasks.  A =NEXT= task
is something that is available to work on /now/, it is the next
logical step in some project.

I used to have a special keyword =ONGOING= for things that I do a lot
and want to clock but never really start/end.  I had a special agenda
view for =ONGOING= tasks that I would pull up to easily find the thing
I want to clock.

Since then I've moved away from using the =ONGOING= todo keyword.
Having an agenda view that shows =NEXT= tasks makes it easy to pick
the thing to clock - and I don't have to remember if I need to look in
the =ONGOING= list or the =NEXT= list when looking for the task to
clock-in.  The =NEXT= list is basically 'what is current' - any task
that moves a project forward.  I want to find the thing to work on as
fast as I can and actually do work on it - not spend time hunting
through my org files for the task that needs to be clocked-in.

To drop a task off the =NEXT= list simply move it back to the =TODO=
state.
** Filtering
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFiltering
:END:

So many tasks, so little time.  I have hundreds of tasks at any given
time (373 right now).  There is so much stuff to look at it can be
daunting.  This is where agenda filtering saves the day.

It's 11:53AM and I'm in work mode just before lunch.  I don't want to
see tasks that are not work related right now.  I also don't want to
work on a big project just before lunch... so I need to find small
tasks that I can knock off the list.

How do we do this?  Get a list of NEXT tasks from the block agenda and
then narrow it down with filtering.  Tasks are ordered in the NEXT
agenda view by estimated effort so the short tasks are first -- just
start at the top and work your way down.  I can limit the displayed
agenda tasks to those estimates of 10 minutes or less with =/ + 1= and
I can pick something that fits the minutes I have left before I take
off for lunch.
*** Automatically removing context based tasks with / RET
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFilteringContext
:END:

=/ RET= in the agenda is really useful.  This awesome feature was
added to org-mode by John Wiegley.  It removes tasks automatically by
filtering based on a user-provided function.

At work I have projects I'm working on which are assigned by my
manager.  Sometimes priorities changes and projects are delayed to
sometime in the future.  This means I need to stop working on these
immediately.  I put the project task on =HOLD= and work on something
else.  The =/ RET= filter removes =HOLD= tasks and subtasks (because
of tag inheritance).

At home I have some tasks tagged with =farm= since these need to be
performed when I am physically at our family farm.  Since I am there
infrequently I have added =farm= to the list of auto-excluded tags on
my system.  I can always explicitly filter to just =farm= tasks with
=/ TAB farm RET= when I am physically there.

I have the following setup to allow =/ RET= to filter tasks based on
the description above.

#+header: :tangle yes
#+begin_src emacs-lisp

(defun org-current-is-todo ()
  (or (string= "TODO" (org-get-todo-state))
      (string= "NEXT" (org-get-todo-state))))

(defun my-org-agenda-skip-all-siblings-but-first ()
  "Skip all but the first non-done entry."
  (let (should-skip-entry)
    (unless (org-current-is-todo)
      (setq should-skip-entry t))
    (save-excursion
      (while (and (not should-skip-entry) (org-goto-sibling t))
        (when (org-current-is-todo)
          (setq should-skip-entry t))))
    (when should-skip-entry
      (or (outline-next-heading)
          (goto-char (point-max))))))

#+end_src

This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not
supposed to be working on now from the list of returned results.

This helps to keep my agenda clutter-free.
* Time Clocking
:PROPERTIES:
:CUSTOM_ID: Clocking
:END:

** Clock Setup
:PROPERTIES:
:CUSTOM_ID: ClockSetup
:END:

To get started we need to punch in which clocks in the default
task and keeps the clock running.  This is now simply a matter of
punching in the clock with =F9 I=.  You can do this anywhere.
Clocking out will now clock in the parent task (if there is one
with a todo keyword) or clock in the default task if not parent
exists.

Keeping the clock running when moving a subtask to a =DONE= state
means clocking continues to apply to the project task.  I can pick the
next task from the parent and clock that in without losing a minute or
two while I'm deciding what to work on next.

I keep clock times, state changes, and other notes in the =:LOGBOOK:=
drawer.

I have the following org-mode settings for clocking:

#+header: :tangle yes
#+begin_src emacs-lisp
;;
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)
;;
;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)

(setq bh/keep-clock-running nil)

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
      ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+end_src

I used to clock in tasks by ID using the following function but with
the new punch-in and punch-out I don't need these as much anymore.
=f9-SPC= calls =bh/clock-in-last-task= which switches the clock back
to the previously clocked task.

#+header: :tangle yes
#+begin_src emacs-lisp
(require 'org-id)
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src
** Clock Everything - Create New Tasks
:PROPERTIES:
:CUSTOM_ID: ClockEverythingWithNewTasks
:END:

In order to clock everything you need a task for everything.  That's
fine for planned projects but interruptions inevitably occur and you
need some place to record whatever time you spend on that
interruption.

To deal with this we create a new capture task to record the thing we
are about to do.  The workflow goes something like this:

- You are clocking some task and an interruption occurs
- Create a quick capture task journal entry =C-c c j=
- Type the heading
- go do that thing (eat lunch, whatever)
- file it =C-c C-c=, this restores the clock back to the previous clocking task
- clock something else in or continue with the current clocking task

This means you can ignore the details like where this task really
belongs in your org file layout and just get on with completing the
thing.  Refiling a bunch of tasks later in a group when it is
convenient to refile the tasks saves time in the long run.

If it's a one-shot uninteresting task (like a coffee break) I create
a capture journal entry for it that goes to the diary.org date tree.
If it's a task that actually needs to be tracked and marked done, and 
applied to some project then I create a capture task instead which files it in 
refile.org.
** Finding tasks to clock in
:PROPERTIES:
:CUSTOM_ID: FindTasksToClockIn
:END:

To find a task to work on I use one of the following options
(generally listed most frequently used first)

- Use the clock history C-u C-c C-x C-i
  Go back to something I was clocking that is not finished
- Pick something off today's block agenda
  =SCHEDULED= or =DEADLINE= items that need to be done soon
- Pick something off the =NEXT= tasks agenda view
  Work on some unfinished task to move to completion
- Pick something off the other task list 
- Use an agenda view with filtering to pick something to work on

Punching in on the task you select will restrict the agenda view to that project
so you can focus on just that thing for some period of time.
** Editing clock entries
:PROPERTIES:
:CUSTOM_ID: EditingClockEntries
:END:

Sometimes it is necessary to edit clock entries so they reflect
reality.  I find I do this for maybe 2-3 entries in a week.

Occassionally I cannot clock in a task on time because I'm away from
my computer.  In this case the previous clocked task is still running
and counts time for both tasks which is wrong.

I make a note of the time and then when I get back to my computer I
clock in the right task and edit the start and end times to correct
the clock history.

To visit the clock line for an entry quickly use the agenda log mode.
=F12 a l= shows all clock lines for today.  I use this to navigate to
the appropriate clock lines quickly.  F11 goes to the current clocked
task but the agenda log mode is better for finding and visiting older
clock entries.

Use =F12 a l= to open the agenda in log mode and show only logged
clock times.  Move the cursor down to the clock line you need to edit
and hit =TAB= and you're there.

To edit a clock entry just put the cursor on the part of the date you
want to edit (use the keyboard not the mouse - since the clicking on
the timestamp with the mouse goes back to the agenda for that day) and
hit the =S-<up arrow>= or =S-<down arrow>= keys to change the time.

The following setting makes time editing use discrete minute intervals (no rounding)
increments:
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-time-stamp-rounding-minutes (quote (1 1)))
#+end_src

Editing the time with the shift arrow combination also updates the
total for the clock line which is a nice convenience.

I always check that I haven't created task overlaps when fixing time
clock entries by viewing them with log mode on in the agenda.  There
is a new view in the agenda for this -- just hit =v c= in the daily 
agenda and clock gaps and overlaps are identified.

I want my clock entries to be as accurate as possible.

The following setting shows 1 minute clocking gaps.
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))
#+end_src
* Time reporting and tracking
:PROPERTIES:
:CUSTOM_ID: TimeReportingAndTracking
:END:
** Task Estimates and column view
:PROPERTIES:
:CUSTOM_ID: TaskEstimates
:END:

Estimating how long tasks take to complete is a difficult skill to
master.  Org-mode makes it easy to practice creating estimates for
tasks and then clock the actual time it takes to complete.

By repeatedly estimating tasks and reviewing how your estimate relates
to the actual time clocked you can tune your estimating skills.
*** Creating a task estimate with column mode
:PROPERTIES:
:CUSTOM_ID: CreatingTaskEstimates
:END:

I use =properties= and =column view= to do project estimates.

I set up column view globally with the following headlines
#+header: :tangle yes
#+begin_src emacs-lisp
; Set default column view headings
(setq org-columns-default-format
      "%65ITEM(Task) %5PRIORITY(PR) %10committed_effort(Commit){:} %10EFFORT(Effort){:} %10CLOCKSUM{:}")
#+end_src

This makes column view show estimated task effort and clocked times
side-by-side which is great for reviewing your project estimates.

A property called =Effort= records the estimated amount of time a
given task will take to complete.  The estimate times I use are one
of:

- 10 minutes
- 30 minutes
- 1 hour
- 2 hours
- 3 hours
- 4 hours
- 5 hours
- 6 hours
- 7 hours
- 8 hours

These are stored for easy use in =column mode= in the global property
=Effort_ALL=.
#+header: :tangle yes
#+begin_src emacs-lisp
; global Effort estimate values
; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:07 0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 0:00")
                                    ("STYLE_ALL" . "habit"))))
#+end_src

To create an estimate for a task or subtree start column mode with
=C-c C-x C-c= and collapse the tree with =c=.  This shows a table
overlayed on top of the headlines with the task name, effort estimate,
and clocked time in columns.

With the cursor in the =Effort= column for a task you can easily set
the estimated effort value with the quick keys =1= through =9=.

After setting the effort values exit =column mode= with =q=.
** Providing progress reports to others
:PROPERTIES:
:CUSTOM_ID: ProgressReporting
:END:
[2012-02-12 Sun 16:11]

When someone wants details of what I've done recently I simple generate a
log report in the agenda with tasks I've completed and state changes combined
with a clock report for the appropriate time period.

The following setting shows closed tasks and state changes in the
agenda.  Combined with the agenda clock report ('R') I can quickly
generate all of the details required.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed)))
#+end_src

To generate the report I pull up the agenda for the appropriate time frame
(today, yesterday, this week, or last week) and hit the key sequence
=l R= to add the log report (without clocking data lines) and the agenda clock
report at the end.

Then it's simply a matter of exporting the resulting agenda in some useful format
to provide to other people.  =C-x C-w /tmp/agenda.html RET= exports to HTML
and =C-x C-w /tmp/agenda.txt RET= exports to plain text.  Other formats are 
available but I use these two the most.

Combining this export with tag filters and =C-u R= can limit the
report to exactly the tags that people are interested in.

* Tags
:PROPERTIES:
:CUSTOM_ID: OrgTagAlist
:END:

#+header: :tangle yes
#+begin_src emacs-lisp

; Not an expert
(setq org-fast-tag-selection-single-key nil);(quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src
* Handling Notes
:PROPERTIES:
:CUSTOM_ID: HandlingNotes
:END:

  Notes are little gems of knowledge that you come across during your
  day.  They are just like tasks except there is nothing to do (except
  learn and memorize the gem of knowledge).  Unfortunately there are way
  too many gems to remember and my head explodes just thinking about it.

  org-mode to the rescue!

  Often I'll find some cool feature or thing I want to remember while
  reading the org-mode and git mailing lists in Gnus.  To create a note
  I use my note capture template =C-c c n=, type a heading for the note
  and =C-c C-c= to save it.  The only other thing to do is to refile it
  (later) to the appropriate project file.

  I have an agenda view just to find notes.  Notes are refiled to an
  appropriate project file and task.  If there is no specific task it
  belongs to it goes to the catchall =* Notes= task.  I generally have a
  catchall notes task in every project file.  Notes are created with a
  =NOTE= tag already applied by the capture template so I'm free to
  refile the note anywhere.  As long as the note is in a project file
  that contributes to my agenda (ie. in org-agenda-files) then I can
  find the note back easily with my notes agenda view by hitting the key
  combination =F12 N=.  I'm free to limit the agenda view of notes using
  standard agenda tag filtering.

  Short notes with a meaningful headline are a great way to remember
  technical details without the need to actually remember anything -
  other than how to find them back when you need them using =F12 N=.

  Notes that are project related and not generally useful can be
  archived with the project and removed from the agenda when the project
  is removed.

  So my org notes go in org.org and my git notes go in git.org both
  under the =* Notes= task.  I'll forever be able to find those.  A note
  about some work project detail I want to remember with the project is
  filed to the project task under the appropriate work org-mode file and
  eventually gets removed from the agenda when the project is complete
  and archived.
* GTD stuff
:PROPERTIES:
:CUSTOM_ID: GTD
:END:

Most of my day is deadline/schedule driven.
I work off of the agenda first and then pick items from the todo lists as
outlined in [[#WhatDoIWorkOnNext][What do I work on next?]]
** Weekly Review Process
:PROPERTIES:
:CUSTOM_ID: GTDWeeklyReview
:END:

The first day of the week (usually Monday) I do my weekly review. 
I keep a list like this one to remind me what needs to be done.

To keep the agenda fast I set
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-span 'day)
#+end_src
so only today's date is shown by default.  I only need the weekly
view during my weekly review and this keeps my agenda generation
fast.

I have a recurring task which keeps my weekly review checklist
handy.  This pops up as a reminder on Monday's.  This week I'm
doing my weekly review on Tuesday since Monday was a holiday.

* Archiving
:PROPERTIES:
:CUSTOM_ID: Archiving
:END:
** Archiving Subtrees
:PROPERTIES:
:CUSTOM_ID: ArchivingSubtrees
:END:

My archiving procedure has changed.  I used to move entire subtrees to
a separate archive file for the project.  Task subtrees in =FILE.org=
get archived to =FILE.org_archive= using the =a y= command in the
agenda.

I still archive to the same archive file as before but now I archive
any done state todo task that is old enough to archive.  Tasks to
archive are listed automatically at the end of my block agenda and
these are guaranteed to be old enough that I've already billed any
time associated with these tasks.  This cleans up my project trees and
removes the old tasks that are no longer interesting.  The archived
tasks get extra property data created during the archive procedure so
that it is possible to reconstruct exactly where the archived entry
came from in the rare case where you want to unarchive something.

My archive files are huge but so far I haven't found a need to split
them by year (or decade) :)

Archivable tasks show up in the last section of my block agenda when a
new month starts.  Any tasks that are done but have no timestamps this
month or last month (ie. they are over 30 days old) are available to
archive.  Timestamps include closed dates, notes, clock data, etc - any
active or inactive timestamp in the task.

Archiving is trivial.  Just mark all of the entries in the block agenda
using the =m= key and then archive them all to the appropriate place
with =B $=.  This normally takes less than 5 minutes once a month.
** Archive Setup
:PROPERTIES:
:CUSTOM_ID: ArchiveSetup
:END:

I no longer use an =ARCHIVE= property in my subtrees.  Tasks can just
archive normally to the =Archived Tasks= heading in the archive file.

The following setting ensures that task states are untouched when they
are archived.  This makes it possible to archive tasks that are not
marked =DONE=.  By default tasks are archived under the heading =*
Archived Tasks= in the archive file.

This archiving function does not keep your project trees intact.  It
archives done state tasks after they are old enough to they are
removed from the main org file.  It should be possible to reconstruct
the original tree from the archive detail properties but I've never
needed to do this yet.  The archived detail is very useful the few
times a year I actually need to look for some archived data but most
of the time I just move it out of the way and keep it for historical
purposes.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::* Archived Tasks")
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving"
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))
#+end_src
** Archive Tag - Hiding Information
:PROPERTIES:
:CUSTOM_ID: ArchiveTagHidesInfo
:END:

The only time I set the ARCHIVE tag on a task is to prevent it from
opening by default because it has tons of information I don't really
need to look at on a regular basis.  I can open the task with C-TAB if
I need to see the gory details (like a huge table of data related to
the task) but normally I don't need that information displayed.
** When to Archive
:PROPERTIES:
:CUSTOM_ID: WhenToArchive
:END:

Archiving monthly works well for me.  I keep completed tasks around
for at least 30 days before archiving them.  This keeps current
clocking information for the last 30 days out of the archives.  This
keeps my files that contribute to the agenda fairly current (this
month, and last month, and anything that is unfinished).  I only
rarely visit tasks in the archive when I need to pull up ancient
history for something.

Archiving keeps my main working files clutter-free.  If I ever need
the detail for the archived tasks they are available in the
appropriate archive file.
* Publishing and Exporting
:PROPERTIES:
:CUSTOM_ID: Publishing
:END:

I don't do a lot of publishing for other people but I do keep a set of
private client system documentation online.  Most of this
documentation is a collection of notes exported to HTML.

Everything at http://doc.norang.ca/ is generated by publishing
org-files.  This includes the index pages on this site.

Org-mode can export to a variety of publishing formats including (but not limited to)

- ASCII
  (plain text - but not the original org-mode file)
- HTML 
- LaTeX
- Docbook
  which enables getting to lots of other formats like ODF, XML, etc
- PDF
  via LaTeX or Docbook
- iCal

I haven't begun the scratch the surface of what org-mode is capable of
doing.  My main use case for org-mode publishing is just to create
HTML documents for viewing online conveniently.  Someday I'll get time
to try out the other formats when I need them for something.
** New Exporter Setup 
[2013-04-20 Sat 08:18]

The new exporter created by Nicolas Goaziou was introduced in org 8.0.

I have the following setup for the exporters I use.

Alphabetical listing options need to be set before the exporters are
loaded for filling to work correctly.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-alphabetical-lists t)

;; Explicitly load required exporters
(require 'ox-html)
(require 'ox-latex)
(require 'ox-ascii)
#+end_src


*** Conversion from the old exporter to the new exporter
[2013-04-20 Sat 08:20]

Here is the list of changes I made to move from the old exporter (pre
org 8.0) to the new exporter.

- Explicitly require exporters

  - Add =ox-html=

  - Add =ox-latex=

  - Add =ox-ascii=

- Rename variables

  - =org-export-html-style-extra= to =org-html-head-extra=

  - =org-export-html-validation-link= to =org-html-validation-link=

  - =org-export-html-inline-images= to =org-html-inline-images=

  - =org-export-html-style-include-default= to =org-html-head-include-default-style=

  - =org-export-html-xml-declaration= to =org-html-xml-declaration=

  - =org-export-latex-listings= to =org-latex-listings=

  - =org-export-html-style-include-scripts= to =org-html-head-include-scripts=

- Publishing changes

  - Rename =:publishing-function=

    - =org-publish-org-to-html= to =org-html-publish-to-html=

    - =org-publish-org-to-org= to =org-org-publish-to-org=

  - Change =:style= to =:html-head=

- Change =bh/is-late-deadline= to handle modified deadline string in agenda

- Reverse agenda sorting for late deadlines

  These are no longer reported with negative values on the agenda

- Add a blank line after my inactive timestamps following headings to
  prevent them from being exported.

** Miscellaneous Export Settings
:PROPERTIES:
:CUSTOM_ID: MiscBabelExportSettings
:END:

This is a collection of export and publishing related settings that I
use.
*** Fontify Latex listings for source blocks
:PROPERTIES:
:CUSTOM_ID: FontifyLatexListings
:END:

For export to latex I use the following setting to get fontified
listings from source blocks:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-latex-listings t)
#+end_src
* Reminders
:PROPERTIES:
:CUSTOM_ID: Reminders
:END:

I use appt for reminders.  It's simple and unobtrusive -- putting
pending appointments in the status bar and beeping as 12, 9, 6, 3,
and 0 minutes before the appointment is due.

Everytime the agenda is displayed (and that's lots for me) the
appointment list is erased and rebuilt from the current agenda
details for today.  This means everytime I reschedule something, add
or remove tasks that are time related the appointment list is
automatically updated the next time I look at the agenda.
** Reminder Setup
:PROPERTIES:
:CUSTOM_ID: ReminderSetup
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
 (require 'time-stamp)
; Erase all reminders and rebuilt reminders for today from the agenda
(defun bh/org-agenda-to-appt ()
  (interactive)
  (message "updating reminders %s" (time-stamp-string))
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-agenda-finalize-hook 'bh/org-agenda-to-appt 'append)
; This is at the end of my .emacs - so appointments are set up when Emacs starts
(bh/org-agenda-to-appt)

; Activate appointments so we get notifications
(appt-activate t)

; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)
#+end_src
* Productivity Tools
:PROPERTIES:
:CUSTOM_ID: ProductivityTools
:NOBLOCKING: t
:END:

This section is a miscellaneous collection of Emacs customizations that I use
with org-mode so that it Works-For-Me(tm).
** Tuning the Agenda Views
:PROPERTIES:
:CUSTOM_ID: TuningAgendaViews
:END:

Various customizations affect how the agenda views show task details.
This section shows each of the customizations I use in my workflow.
*** Highlight the current agenda line
:PROPERTIES:
:CUSTOM_ID: HighlightCurrentAgendaLine
:END:

The following code in my =.emacs= file keeps the current agenda line
highlighted.  This makes it obvious what task will be affected by
commands issued in the agenda.  No more acting on the wrong task by
mistake!

The clock modeline time is also shown with a reverse background.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)
#+end_src

#+header: :tangle no
#+begin_src emacs-lisp
;; The following custom-set-faces create the highlights
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t))
#+end_src
*** Keep tasks with timestamps visible on the global todo lists
:PROPERTIES:
:CUSTOM_ID: GlobalTodoListsShowAllTasks
:END:

Tasks with dates (=SCHEDULED:=, =DEADLINE:=, or active dates) show up
in the agenda when appropriate.  The block agenda view (=F12 a=) tries
to keep tasks showing up only in one location (either in the calendar
or other todo lists in later sections of the block agenda.)  I now
rarely use the global todo list search in org-mode (=F12 t=, =F12 m=)
and when I do I'm trying to find a specific task quickly.  These lists
now include _everything_ so I can just search for the item I want and
move on.

The block agenda prevents display of tasks with deadlines or scheduled
dates in the future so you can safely ignore these until the
appropriate time.
#+header: :tangle yes
#+begin_src emacs-lisp
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)
#+end_src
*** Searches include archive files
:PROPERTIES:
:CUSTOM_ID: SearchesIncludeArchiveFiles
:END:

I keep a single archive file for each of my org-mode project files.
This allows me to search the current file and the archive when I need
to dig up old information from the archives.

I don't need this often but it sure is handy on the occasions that
I do need it.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+end_src
*** Agenda view tweaks
:PROPERTIES:
:CUSTOM_ID: AgendaViewTweaks
:END:

#+header: :tangle yes
#+begin_src emacs-lisp
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

;; Enable display of the time grid so we can see the marker for the current time
;(setq org-agenda-time-grid (quote ((daily today remove-match)
 ;                                  #("----------------" 0 16 (org-heading t))
  ;                                 (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)


#+end_src
*** Sticky Agendas
:PROPERTIES:
:CUSTOM_ID: StickyAgendas
:END:
[2013-06-23 Sun 10:16]

Sticky agendas allow you to have more than one agenda view created simultaneously.
You can quickly switch to the view without incurring an agenda rebuild by invoking
the agenda custom command key that normally generates the agenda.  If it already 
exists it will display the existing view.  =g= forces regeneration of the agenda view.

I normally have two views displayed (=F12 a= for the daily/weekly
agenda and =F12 SPC= for my project management view)

#+header: :tangle yes
#+begin_src emacs-lisp
;; Use sticky agenda's so they persist
(setq org-agenda-sticky t)
#+end_src
** Checklist handling
:PROPERTIES:
:CUSTOM_ID: ChecklistHandling
:END:

Checklists are great for repeated tasks with lots of things that need
to be done.  For a long time I was manually resetting the check boxes
to unchecked when marking the repeated task =DONE= but no more!
There's a contributed =org-checklist= that can uncheck the boxes
automagically when the task is marked done.

Add the following to your =.emacs=

#+header: :tangle no
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "~/extern/org-mode/contrib/lisp"))

(require 'org-checklist)
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp :exports none
;; The following setting is different from the document so that you
;; can override the document path by setting your path in the variable
;; org-mode-user-contrib-lisp-path
;;
(if (boundp 'org-mode-user-contrib-lisp-path)
    (add-to-list 'load-path org-mode-user-contrib-lisp-path)
  (add-to-list 'load-path (expand-file-name "~/extern/org-mode/contrib/lisp")))

(require 'org-checklist)
#+end_src

and then to use it in a task you simply set the property =RESET_CHECK_BOXES= to =t= 
like this

#+begin_src org :exports src
,* TODO Invoicing and Archive Tasks [0/7]
  DEADLINE: <2009-07-01 Wed +1m -0d> 
  :PROPERTIES:
  :RESET_CHECK_BOXES: t
  :END:

  - [ ] Do task 1
  - [ ] Do task 2
  ...
  - [ ] Do task 7
#+end_src
** Backups
:PROPERTIES:
:CUSTOM_ID: Backups
:END:

=Backups that you have to work hard at don't get done=.

I lost a bunch of data over 10 years ago due to not having a working
backup solution.  At the time I said =I'm not going to lose any
important data ever again=.  So far so good :)

My backups get done religiously.  What does this have to do with
org-mode?  Not much really, other than I don't spend time doing
backups -- they just happen -- which saves me time for other more
interesting things.

My backup philosophy is to make it possible to recover your data --
not necessarily easy.  It doesn't have to be easy/fast to do the
recovery because I'll rarely have to recover data from the backups.
Saving time for recovery doesn't make sense to me.  I want the backup
to be fast and painless since I do those all the time.

I set up an automated network backup over 10 years ago that is still
serving me well today.  All of my systems gets daily backups to a
network drive.  These are collected monthly and written to an external
removable USB disk.

Once a month my task for backups prompts me to move the current
collection of montly backups to the USB drive for external storage.
Backups take minimal effort currently and I'm really happy about that.

Since then =git= came into my life, so backups of =git= repositories
that are on multiple machines is much less critical than it used to
be.  There is an automatic backup of everything pushed to the remote
repository.
** Handling blocked tasks
:PROPERTIES:
:CUSTOM_ID: HandlingBlockedTasks
:END:

Blocked tasks are tasks that have subtasks which are not in a done
todo state.  Blocked tasks show up in a grayed font by default in the
agenda.

To enable task blocking set the following variable:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

This setting prevents tasks from changing to =DONE= if any subtasks
are still open.  This works pretty well except for repeating tasks.  I
find I'm regularly adding =TODO= tasks under repeating tasks and not
all of the subtasks need to be complete before the next repeat cycle.

You can override the setting temporarily by changing the task with
=C-u C-u C-u C-c C-t= but I never remember that.  I set a permanent
property on the repeated tasks as follows:

#+begin_src org :exports src
,* TODO New Repeating Task
  SCHEDULED: <2009-06-16 Tue +1w>
  :PROPERTIES:
  :NOBLOCKING: t
  :END:
  ...
,** TODO Subtask  
#+end_src

This prevents the =New Repeating Task= from being blocked if some of
the items under it are not complete.

Occassionally I need to complete tasks in a given order.  Org-mode has
a property =ORDERED= that enforces this for subtasks.

#+begin_src org :exports src
,* TODO Some Task
  :PROPERTIES:
  :ORDERED: t
  :END:
,** TODO Step 1
,** TODO Step 2
,** TODO Step 3  
#+end_src

In this case you need to complete =Step 1= before you can complete
=Step 2=, etc. and org-mode prevents the state change to a done task
until the preceding tasks are complete.
** Org Task structure and presentation
:PROPERTIES:
:CUSTOM_ID: OrgTaskStructureAndPresentation
:END:

This section describes various org-mode settings I use to control how
tasks are displayed while I work on my org mode files.
*** Controlling display of leading stars on headlines
:PROPERTIES:
:CUSTOM_ID: DisplayLeadingStars
:END:

Org-mode has the ability to show or hide the leading stars on task
headlines.  It's also possible to have headlines at odd levels only so
that the stars and heading task names line up in sublevels.

To make org show leading stars use

#+header: :tangle yes
#+begin_src emacs-lisp 
(setq org-hide-leading-stars nil)
#+end_src

I now use org-indent mode which hides leading stars.
*** org-indent mode
:PROPERTIES:
:CUSTOM_ID: OrgIndentMode
:END:

I recently started using org-indent mode.  I like this setting a lot.
It removes the indentation in the org-file but displays it as if it
was indented while you are working on the org file buffer.

org-indent mode displays as if org-odd-levels-only is true but it has
a really clean look that I prefer over my old setup.

I have org-indent mode on by default at startup with the following
setting:
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-startup-indented t)
#+end_src
*** Handling blank lines
:PROPERTIES:
:CUSTOM_ID: HandlingBlankLines
:END:

Blank lines are evil :).  They keep getting inserted in between
headlines and I don't want to see them in collapsed (contents) views.
When I use =TAB= to fold (cycle) tasks I don't want to see any blank
lines between headings.

The following setting hides blank lines between headings which keeps
folded view nice and compact.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-cycle-separator-lines 0)
#+end_src

I find extra blank lines in lists and headings a bit of a nuisance.
To get a body after a list you need to include a blank line between
the list entry and the body -- and indent the body appropriately.
Most of my lists have no body detail so I like the look of collapsed
lists with no blank lines better.

The following setting prevents creating blank lines before headings
but allows list items to adapt to existing blank lines around the items:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-blank-before-new-entry (quote ((heading)
                                         (plain-list-item . auto))))
#+end_src
*** Adding new tasks quickly without disturbing the current task content
:PROPERTIES:
:CUSTOM_ID: AddingNewTasks
:END:

To create new headings in a project file it is really convenient to
use =C-RET=, =C-S-RET=, =M-RET=, and =M-S-RET=.  This inserts a new headline
possibly with a =TODO= keyword.  With the following setting

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-insert-heading-respect-content nil)
#+end_src

org inserts the heading at point for the =M-= versions and respects
content for the =C-= versions.  The respect content setting is
temporarily turned on for the =C-= versions which adds the new heading
after the content of the current item.  This lets you hit =C-S-RET= in
the middle of an entry and the new heading is added after the body of
the current entry but still allow you to split an entry in the middle
with =M-S-RET=.
*** Notes at the top
:PROPERTIES:
:CUSTOM_ID: NotesAtTop
:END:

I enter notes for tasks with =C-c C-z= (or just =z= in the agenda).
Changing tasks states also sometimes prompt for a note (e.g. moving to
=WAITING= prompts for a note and I enter a reason for why it is
waiting).  These notes are saved at the top of the task so unfolding
the task shows the note first.
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-reverse-note-order nil)
#+end_src
*** Searching and showing results
:PROPERTIES:
:CUSTOM_ID: SearchingResults
:END:

Org-mode's searching capabilities are really effective at finding data
in your org files.  =C-c / /= does a regular expression search on the
current file and shows matching results in a collapsed view of the
org-file.

I have org-mode show the hierarchy of tasks above the matched entries
and also the immediately following sibling task (but not all siblings)
with the following settings:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-show-following-heading t)
(setq org-show-hierarchy-above t)
(setq org-show-siblings (quote ((default))))
#+end_src

This keeps the results of the search relatively compact and mitigates
accidental errors by cutting too much data from your org file with
=C-k=.  Cutting folded data (including the ...) can be really
dangerous since it cuts text (including following subtrees) which you
can't see.  For this reason I always show the following headline when
displaying search results.
*** Editing and Special key handling
:PROPERTIES:
:CUSTOM_ID: SpecialKeyHandling
:END:

Org-mode allows special handling of the C-a, C-e, and C-k keys while
editing headlines.  I also use the setting that pastes (yanks)
subtrees and adjusts the levels to match the task I am pasting to.
See the docstring (=C-h v org-yank-adjust-subtrees=) for more details
on each variable and what it does.

I have =org-special-ctrl-a/e= set to enable easy access to the
beginning and end of headlines. I use =M-m= or =C-a C-a= to get to the
beginning of the line so the speed commands work and =C-a= to give
easy access to the beginning of the heading text when I need that.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k t)
(setq org-yank-adjusted-subtrees t)
#+end_src
** Attachments
:PROPERTIES:
:CUSTOM_ID: Attachments
:END:
Attachments are great for getting large amounts of data related to
your project out of your org-mode files.  Before attachments came
along I was including huge blocks of SQL code in my org files to keep
track of changes I made to project databases.  This bloated my org
file sizes badly.

Now I can create the data in a separate file and attach it to my
project task so it's easily located again in the future.

I set up org-mode to generate unique attachment IDs with
=org-id-method= as follows:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-id-method (quote uuidgen))
#+end_src

Say you want to attach a file =x.sql= to your current task.  Create
the file data in =/tmp/x.sql= and save it.

Attach the file with =C-c C-a a= and enter the filename: =x.sql=.
This generates a unique ID for the task and adds the file in the
attachment directory.

#+begin_src org :exports src
,* Attachments                                                        :ATTACH:
  :PROPERTIES:
  :Attachments: x.sql
  :ID:       f1d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b
  :END:  
#+end_src

The attached file is saved in
=data/f1/d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b/=.  Where it goes exactly
isn't important for me -- as long as it is saved and retrievable
easily.  Org-mode copies the original file =/tmp/x.sql= into the
appropriate attachment directory.

Tasks with attachments automatically get an =ATTACH= tag so you can
easily find tasks with attachments with a tag search.

To open the attachment for a task use =C-c C-a o=.  This prompts for
the attachment to open and =TAB= completion works here.

The =ID= changes for every task header when a new =ID= is generated.

It's possible to use named directories for attachments but I haven't
needed this functionality yet -- it's there if you need it.

I store my org-mode attachments with my org files in a subdirectory
=data=.  These are automatically added to my =git= repository along
with any other org-mode changes I've made.
** Deadlines and Agenda Visibility
:PROPERTIES:
:CUSTOM_ID: DeadlinesAndAgendaVisibility
:END:

Deadlines and due dates are a fact or life.  By default I want to see
deadlines in the agenda 30 days before the due date.

The following setting accomplishes this:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-deadline-warning-days 30)
#+end_src

This gives me plenty of time to deal with the task so that it is
completed on or before the due date.

I also use deadlines for repeating tasks.  If the task repeats more
often than once per month it would be always bugging me on the agenda
view.  For these types of tasks I set an explicit deadline warning
date as follows:

#+begin_src org :exports src
,* TODO Pay Wages
  DEADLINE: <2009-07-01 Wed +1m -0d>   
#+end_src

This example repeats monthly and shows up in the agenda on the day it
is due (with no prior warning).  You can set any number of lead days
you want on DEADLINES using -Nd where N is the number of days in
advance the task should show up in the agenda.  If no value is
specified the default =org-deadline-warning-days= is used.
** Exporting Tables to CSV
:PROPERTIES:
:CUSTOM_ID: TableExportToCSV
:END:

I generate org-mode tables with details of task specifications and
record structures for some of my projects.  My clients like to use
spreadsheets for this type of detail.

It's easy to share the details of the org-mode table by exporting in
HTML but that isn't easy for anyone else to work with if they need to
edit data.

To solve this problem I export my table as comma delimited values
(CSV) and then send that to the client (or read it into a spreadsheet
and email the resulting spreadsheet file).

Org-mode can export tables as TAB or comma delimited formats.  I set
the default format to CSV with:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-table-export-default-format "orgtbl-to-csv")
#+end_src

Exporting to CSV format is the only one I use and this provides the
default so I can just hit RETURN when prompted for the format.

To export the following table I put the cursor inside the table and
hit =M-x org-table-export= which prompts for a filename and the format
which defaults to orgtbl-to-csv from the setting above.

|   One |    Two | Three |
|-------+--------+-------|
|     1 |      1 |     2 |
|     3 |      6 |     5 |
|  fred |    kpe |  mary |
| 234.5 | 432.12 | 324.3 |

This creates the file with the following data

#+begin_src csv
One,Two,Three
1,1,2
3,6,5
fred,kpe,mary
234.5,432.12,324.3
#+end_src
** Minimize Emacs Frames
:PROPERTIES:
:CUSTOM_ID: MinimizeFrames
:END:

Links to emails, web pages, and other files are sprinkled all over my
org files.  The following setting control how org-mode handles opening
the link.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-link-frame-setup (quote ((file . find-file))))

; Use the current window for C-c ' source editing
(setq org-src-window-setup 'current-window)
#+end_src

I like to keep links in the same window so that I don't end up with a
ton of frames in my window manager.  I normally work in a full-screen
window and having links open in the same window just works better for
me.

If I need to work in multiple files I'll manually create the second
frame with =C-x 5 2= or split the window with =C-x 4 2= or =C-X 4 3=.
When I visit files in Emacs I normally want to replace the current
window with the new content.

** Logging stuff
:PROPERTIES:
:CUSTOM_ID: LoggingStuff
:END:

Most of my logging is controlled by the global =org-todo-keywords=

My logging settings are set as follows:
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-log-done (quote time))
(setq org-log-into-drawer t)
#+end_src

My =org-todo-keywords= are set as follows:

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote (
              (sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")
              (sequence "GOAL(g)" "|"))))
#+end_src

This adds a log entry whenever a task moves to any of the following states:
- to or out of =DONE= status
- to =WAITING= status (with a note) or out of =WAITING= status
- to =HOLD= status
- to =CANCELLED= status (with a note) or out of =CANCELLED= status

I keep clock times and states in the =LOGBOOK= drawer to keep my tasks
uncluttered.  If a task is WAITING then the reason for why it is
waiting is near the top of the LOGBOOK and unfolding the LOGBOOK
drawer provides that information.  From the agenda simply hitting
=SPC= on the task will reveal the LOGBOOK drawer.
** Limiting time spent on tasks
:PROPERTIES:
:CUSTOM_ID: LimitingTimeSpentOnTasks
:END:

Org-mode has this great new feature for signalling alarms when the
estimated time for a task is reached.  I use this to limit the amount
of time I spend on a task during the day.

As an example, I've been working on this document for over two months
now.  I want to get it finished but I can't just work on it solely
until it's done because then nothing else gets done.  I want to do a
little bit every day but limit the total amount of time I spend
documenting org-mode to an hour a day.

To this end I have a task

#+begin_src org :exports src
,* NEXT Document my use of org-mode
  :LOGBOOK:...
  :PROPERTIES:
  :CLOCK_MODELINE_TOTAL: today
  :Effort:   1:00
  :END:  
#+end_src

The task has an estimated effort of 1 hour and when I clock in the
task it gives me a total in the mode-line like this

: --:**  org-mode.org   91% (2348,73) Git:master  (Org Fly yas Font)-----[0:35/1:00 (Document my use of org-mode)]-------

I've spent 35 minutes of my 1 hour so far today on this document and
other help on IRC.

I set up an alarm so the Star Trek door chime goes off when the
total estimated time is hit.  (Yes I'm a Trekkie :) )

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-clock-sound "/usr/local/lib/tngchime.wav")
#+end_src

When the one hour time limit is hit the alarm sound goes off and a
message states that I should be done working on this task.  If I
switch tasks and try to clock in this task again I get the sound each
and every time I clock in the task.  This nags me to go work on
something else :)

You can use similar setups for repeated tasks.  By default the last
repeat time is recorded as a property when a repeating task is marked
done.  For repeating tasks the mode-line clock total counts since the
last repeat time by default.  This lets you accumulate time over
multiple days and counts towards your estimated effort limit.
** Habit Tracking
:PROPERTIES:
:CUSTOM_ID: HabitTracking
:END:

John Wiegley recently added support for Habit tracking to org-mode.

I have lots of habits (some bad) but I'd still like to improve and
build new good habits.  This is what habit tracking is for.  It shows
a graph on the agenda of how well you have been doing on developing
your habits.

I have habits like:

- Hand wash the dishes
- 30 minute brisk walk
- Clean the house

etc. and most of these need a push to get done regularly.  Logging of
the done state needs to be enabled for habit tracking to work.

A habit is just like a regular task except it has a special =PROPERTY=
value setting and a special =SCHEDULED= date entry like this:

#+begin_src org :exports src
,* TODO Update Org Mode Doc
  SCHEDULED: <2009-11-21 Sat .+7d/30d>
  [2009-11-14 Sat 11:45]
  :PROPERTIES:
  :STYLE: habit
  :END:  
#+end_src

This marks the task as a habit and separates it from the regular task
display on the agenda.  When you mark a habit done it shows up on your
daily agenda the next time based on the first interval in the
SCHEDULED entry (=.+7d=)

The special =SCHEDULED= entry states that I want to do this every day
but at least every 2 days.  If I go 3 days without marking it DONE it
shows up RED on the agenda indicating that I have been neglecting this
habit.

The world isn't going to end if you neglect your habits.  You can hide
and display habits quickly using the =K= key on the agenda.

These are my settings for habit tracking.

#+header: :tangle yes
#+begin_src emacs-lisp
; Enable habit tracking (and a bunch of other modules)
(setq org-modules (quote (
                          
                          org-crypt
                          org-gnus
                          org-id
                          org-info
                          org-jsinfo
                          org-habit
                          org-inlinetask
                          org-irc
                          org-mew
                          
                          org-protocol
                          
                          org-wl
                          org-w3m)))

; position the habit graph on the agenda to the right of the default
(setq org-habit-graph-column 50)
#+end_src

During the day I'll turn off the habit display in the agenda with =K=.
This is a persistent setting and since I leave my Emacs running for
days at a time my habit display doesn't come back.  To make sure I
look at the habits daily I have the following settings to redisplay
the habits in the agenda each day.  This turns the habit display on
again at 6AM each morning.

#+header: :tangle yes
#+begin_src emacs-lisp
(run-at-time "06:00" 86400 '(lambda () (setq org-habit-show-habits t)))
#+end_src
** Habits only log DONE state changes
:PROPERTIES:
:CUSTOM_ID: HabitsLogDone
:END:

I tend to keep habits under a level 1 task =* Habits= with a special
logging property that only logs changes to the =DONE= state.  This
allows me to cancel a habit and not record a timestamp for it since
that messes up the habit graph.  Cancelling a habit just to get it off
my agenda because it's undoable (like get up before 6AM) should not
mark the habit as done today.  I only cancel habits that repeat every
day.

My habit tasks look as follows - and I tend to have one in every org
file that can have habits defined
#+begin_src org :exports src
,* Habits
  :PROPERTIES:
  :LOGGING:  DONE(!)
  :ARCHIVE:  %s_archive::* Habits
  :END:  
#+end_src
** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: AutoRevertMode
:END:

I use git to synchronize my org-mode files between my laptop and my
workstation.  This normally requires saving all the current changes,
pushing to a bare repo, and fetching on the other system.  After that
I need to revert all of my org-mode files to get the updated
information.

I used to use =org-revert-all-org-buffers= but have since discovered
=global-auto-revert-mode=.  With this setting any files that change on
disk where there are no changes in the buffer automatically revert to
the on-disk version.

This is perfect for synchronizing my org-mode files between systems.

#+header: :tangle yes
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src
** Handling Encryption
:PROPERTIES:
:CUSTOM_ID: HandlingEncryption
:END:

I used to keep my encrypted data like account passwords in a separate
GPG encrypted file.  Now I keep them in my org-mode files with a
special tag instead.  Encrypted data is kept in the org-mode file that
it is associated with.

=org-crypt= allows you to tag headings with a special tag =crypt= and
org-mode can keep data in these headings encrypted when saved to disk.
You decrypt the heading temporarily when you need access to the data
and org-mode re-encrypts the heading as soon as you save the file.

I use the following setup for encryption:
#+header: :tangle yes
#+begin_src emacs-lisp
(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
; GPG key to use for encryption
(setq org-crypt-key "F0B66B40")
#+end_src

=M-x org-decrypt-entry= will prompt for the passphrase associated with
your encryption key and replace the encrypted data where the point is
with the plaintext details for your encrypted entry.  As soon as you
save the file the data is re-encrypted for your key.  Encrypting does
not require prompting for the passphrase - that's only for looking at
the plain text version of the data.

I tend to have a single level 1 encrypted entry per file (like =*
Passwords=).  I prevent the =crypt= tag from using inheritance so that
I don't have encrypted data inside encrypted data.  I found =M-x
org-decrypt-entries= prompting for the passphrase to decrypt data over
and over again (once per entry to decrypt) too inconvenient.

I leave my entries encrypted unless I have to look up data - I decrypt
on demand and then save the file again to re-encrypt the data.  This
keeps the data in plain text as short as possible.
*** Auto Save Files
:PROPERTIES:
:CUSTOM_ID: AutoSaveFiles
:END:
[2011-09-26 Mon 04:57]

Emacs temporarily saves your buffer in an autosave file while you are
editing your org buffer and a sufficient number of changes have
accumulated.  If you have decrypted subtrees in your buffer these will
be written to disk in plain text which possibly leaks sensitive information.
To combat this org-mode now asks if you want to disable the autosave 
functionality in this buffer.

Personally I really like the autosave feature.  99% of the time my encrypted
entries are perfectly safe to write to the autosave file since they are
still encrypted.  I tend to decrypt an entry, read the details for what
I need to look up and then immediately save the file again with =C-x C-s=
which re-encrypts the entry immediately.  This pretty much guarantees that 
my autosave files never have decrypted data stored in them.

I disable the default org crypt auto-save setting as follows:
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-crypt-disable-auto-save nil)
#+end_src
** Highlight clock when running overtime
:PROPERTIES:
:CUSTOM_ID: HighlightClockOvertime
:END:

The current clocking task is displayed on the modeline.  If this has
an estimated time and we run over the limit I make this stand out on
the modeline by changing the background to red as follows

#+header: :tangle yes
#+begin_src emacs-lisp
(custom-set-faces
  ;; custom-set-faces was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(org-mode-line-clock ((t (:foreground "red" :box (:line-width -1 :style released-button)))) t))
#+end_src
** Getting up to date org-mode info documentation
:PROPERTIES:
:CUSTOM_ID: OrgModeInfoDocumentation
:END:

I use the org-mode info documentation from the git repository so I set
up emacs to find the info files from git before the regular (out of
date) system versions.

#+header: :tangle yes
#+begin_src emacs-lisp
(add-to-list 'Info-default-directory-list "~/extern/org-mode/doc")
#+end_src
** Automatically change list bullets
:PROPERTIES:
:CUSTOM_ID: ListBullets
:END:

I take point-form notes during meetings.  Having the same list bullet
for every list level makes it hard to read the details when lists are
indented more than 3 levels.

Org-mode has a way to automatically change the list bullets when you
change list levels.

| Current List Bullet | Next indented list bullet |
|---------------------+---------------------------|
| +                   | -                         |
| *                   | -                         |
| 1.                  | -                         |
| 1)                  | -                         |
| A)                  | -                         |
| B)                  | -                         |
| a)                  | -                         |
| b)                  | -                         |
| A.                  | -                         |
| B.                  | -                         |
| a.                  | -                         |
| b.                  | -                         |

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet (quote (("+" . "-")
                                            ("*" . "-")
                                            ("1." . "-")
                                            ("1)" . "-")
                                            ("A)" . "-")
                                            ("B)" . "-")
                                            ("a)" . "-")
                                            ("b)" . "-")
                                            ("A." . "-")
                                            ("B." . "-")
                                            ("a." . "-")
                                            ("b." . "-"))))
#+end_src
** Remove indentation on agenda tags view
:PROPERTIES:
:CUSTOM_ID: IndentationOnTagsView
:END:

I don't like the indented view for sublevels on a tags match in the
agenda but I want to see all matching tasks (including sublevels) when
I do a agenda tag search (=F12 m=).

To make all of the matched headings for a tag show at the same level
in the agenda set the following variable:
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-tags-match-list-sublevels t)
#+end_src
** Fontify source blocks natively
:PROPERTIES:
:CUSTOM_ID: FontifySrcBlocksNatively
:END:

I use babel for including source blocks in my documents with

#+begin_src org :exports src
,#+begin_src LANG
,  ...
,#+end_src
#+end_src

where LANG specifies the language to use (ditaa, dot, sh, emacs-lisp,
etc)  This displays the language contents fontified in both the
org-mode source buffer and the exported document.

See this [[#git-sync][Git Repository synchronization]] in this document for an example..
** Agenda persistent filters
:PROPERTIES:
:CUSTOM_ID: AgendaPersistentFilters
:END:

This is a great feature!  Persistent agenda filters means if you limit
a search with =/ TAB SomeTag= the agenda remembers this filter until
you change it.

Enable persistent filters with the following variable

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-persistent-filter t)
#+end_src

The current filter is displayed in the modeline as ={+SomeTag}= so you
can easily see what filter currently applies to your agenda view.

I use this with =FILETAGS= to limit the displayed results to a single
client or context.
** Add tags for flagged entries
:PROPERTIES:
:CUSTOM_ID: TagFlaggedEntries
:END:

Everyone so often something will come along that is really important
and you know you want to be able to find it back fast sometime in the
future.

For these types of notes and tasks I add a special =:FLAGGED:= tag.
This tag gets a special fast-key =?= which matches the search key in
the agenda for flagged items.  See [[#OrgTagAlist][Tags]] for the setup of
=org-tag-alist= for the =FLAGGED= entry.

Finding flagged entries is then simple - just =F12 ?= and you get them all.
** Mail links open compose-mail
:PROPERTIES:
:CUSTOM_ID: MailLinksOpenComposeMail
:END:

The following setting makes org-mode open =mailto:= links
using compose-mail.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-link-mailto-program (quote (compose-mail "%a" "%s")))
#+end_src
** Composing mail from org mode subtrees
:PROPERTIES:
:CUSTOM_ID: MailingSubtrees
:END:

It's possible to create mail from an org-mode subtree.  I use =C-c
M-o= to start an email message with the details filled in from the
current subtree.  I use this for repeating reminder tasks where I need
to send an email to someone else.  The email contents are already
contained in the org-mode subtree and all I need to do is =C-c M-o=
and any minor edits before sending it off.
** Remove multiple state change log details from the agenda
:PROPERTIES:
:CUSTOM_ID: StateChangeDetailsInAgenda
:END:
[2011-04-30 Sat 11:14]

I skip multiple timestamps for the same entry in the agenda view with the following setting.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-skip-additional-timestamps-same-entry t)
#+end_src

This removes the clutter of extra state change log details when multiple timestamps
exist in a single entry.
** Drop old style references in tables
:PROPERTIES:
:CUSTOM_ID: OldTableReferences
:END:
[2011-04-30 Sat 11:19]

I drop the old A3/B4 style references from tables when editing with the
following setting.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-table-use-standard-references (quote from))
#+end_src
** Use system settings for file-application selection
:PROPERTIES:
:CUSTOM_ID: SystemSettingsForApplicationSelection
:END:
[2011-04-30 Sat 14:38]

To get consistent applications for opening tasks I set the =org-file-apps= variable as follows:

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-file-apps (quote ((auto-mode . emacs)
                            ("\\.mm\\'" . system)
                            ("\\.x?html?\\'" . system)
                            ("\\.pdf\\'" . system))))
#+end_src

This uses the entries defined in my system =mailcap= settings when
opening file extensions.  This gives me consistent behaviour when
opening an link to some HTML file with =C-c C-o= or when previewing an export.
** Use the current window for the agenda
:PROPERTIES:
:CUSTOM_ID: CurrentWindowForAgenda
:END:
[2011-05-28 Sat 21:20]

#+header: :tangle yes
#+begin_src emacs-lisp
; Overwrite the current window with the agenda
(setq org-agenda-window-setup 'current-window)
#+end_src
** Delete IDs when cloning
:PROPERTIES:
:CUSTOM_ID: DeleteIdsWhenCloning
:END:
[2011-05-28 Sat 21:27]

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-clone-delete-id t)
#+end_src
** Cycling plain lists
:PROPERTIES:
:CUSTOM_ID: CyclePlainLists
:END:

Org mode can fold (cycle) plain lists.
#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-cycle-include-plain-lists t)
#+end_src

I find this setting useful when I have repeating tasks with lots of sublists with
checkboxes.  I can fold the completed list entries and focus on what is remaining easily.
** Showing source block syntax highlighting
:PROPERTIES:
:CUSTOM_ID: ShowSrcBlockSyntax
:END:

It is possible to display org-mode source blocks fontified in their
native mode.  This allows colourization of keywords for C and shell
script source etc.  If I edit the source I use =C-c '= (control-c single
quote) to bring up the source window which is then rendered with
syntax highlighting in the native mode.  This setting also shows the
syntax highlighting when viewing in the org-mode buffer.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src
** Startup in folded view
:PROPERTIES:
:CUSTOM_ID: StartupView
:END:
[2012-04-08 Sun 07:26]

Startup in folded view.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

I used to use content view by default so I could review org subtrees
before archiving but my archiving workflow has changed so I no longer
need this manual step.
** Allow alphabetical list entries
:PROPERTIES:
:CUSTOM_ID: AlphabeticalLists
:END:
[2012-06-06 Wed 22:23]

The following setting adds alphabetical lists like

#+begin_src org :exports src
a. item one
b. item two
#+end_src

#+header: :tangle no
#+begin_src emacs-lisp
(setq org-alphabetical-lists t)
#+end_src

In order for filling to work correctly this needs to be set before the
exporters are loaded.
** Using orgstruct mode for mail
:PROPERTIES:
:CUSTOM_ID: OrgStructModeForMail
:END:
[2012-06-24 Sun 11:16]

=orgstruct++-mode= is enabled in =Gnus= message buffers to aid in
creating structured email messages.

#+header: :tangle yes
#+begin_src emacs-lisp
(add-hook 'message-mode-hook 'orgstruct++-mode 'append)
(add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
(add-hook 'message-mode-hook 'bbdb-define-all-aliases 'append)
(add-hook 'message-mode-hook 'orgtbl-mode 'append)
;(add-hook 'message-mode-hook 'turn-on-flyspell 'append)
(add-hook 'message-mode-hook
          '(lambda () (setq fill-column 72))
          'append)
#+end_src
** Preserving source block indentation
:PROPERTIES:
:CUSTOM_ID: PreserveSourceIndentations
:END:
I do not preserve indentation for source blocks mainly because this doesn't look
nice with indented org-files.  The only reason I've found to preserve indentation is
when TABs in files need to be preserved (e.g. Makefiles).  I don't normally edit
these files in org-mode so I leave this setting turned off.

I've changed the default block indentation so that it is not indented
from the text in the org file.  This allows editing source blocks in 
place without requiring use of =C-c '= so that code lines up correctly.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)
#+end_src
** Prevent editing invisible text
:PROPERTIES:
:CUSTOM_ID: PreventInvisibleEdits
:END:
[2012-07-20 Fri 22:26]

The following setting prevents accidentally editing hidden text when the point is inside a folded region.
This can happen if you are in the body of a heading and globally fold the org-file with =S-TAB=

I find invisible edits (and undo's) hard to deal with so now I can't edit invisible text.  
=C-c C-r= (org-reveal) will display where the point is if it is buried in invisible text
to allow editing again.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'error)
#+end_src
** Use utf-8 as default coding system
:PROPERTIES:
:CUSTOM_ID: DefaultCodingSystem
:END:
[2013-01-01 Tue 13:49]

I use =utf-8= as the default coding system for all of my org files.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-export-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-charset-priority 'unicode)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

** Keep clock durations in hours
:PROPERTIES:
:CUSTOM_ID: ClockDurationsNoDays
:END:
[2013-02-17 Sun 12:37]

The default for clock durations has changed to include days which is
24 hours.  At work I like to think of a day as 6 hours of work (the
rest of the time is lost in meetings and other overhead on average) so
displaying clock durations in days doesn't make sense to me.

The following setting displays clock durations (from =C-c C-x C-d= in
hours and minutes.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-time-clocksum-format
      '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
#+end_src
** Create unique IDs for tasks when linking
:PROPERTIES:
:CUSTOM_ID: LinkingToTaskCreatesId
:END:
[2013-06-23 Sun 10:38]

The following setting creates a unique task ID for the heading in the
=PROPERTY= drawer when I use =C-c l=.  This allows me to move the task
around arbitrarily in my org files and the link to it still works.

#+header: :tangle yes
#+begin_src emacs-lisp
;; (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
(setq org-id-link-to-org-use-id nil)
#+end_src
* Added by Lyn
[2017-06-05 Mon 09:39]

#+header: :tangle yes
#+begin_src emacs-lisp

(add-hook 'org-agenda-finalize-hook 'delete-other-windows)

(add-to-list 'org-file-apps '(directory . emacs))

(require 'ox-confluence)

(defun l-org-refresh-refiles ()
  (interactive)
  (switch-to-buffer "refile.org")
  (save-buffer)
  (find-alternate-file "refile.org")
  (previous-buffer)
  (org-agenda-redo))

(bind-key "g" 'beginning-of-buffer org-agenda-mode-map)

(require 'org-habit)

(setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 3))
#+end_src
** stuck projects

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-stuck-projects'("/!TODO" ("NEXT") () "SCHEDULED:\\|DEADLINE:"))
#+end_src
** projects

#+header: :tangle yes
#+begin_src emacs-lisp


(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

; need: function returns nil to keep a project
; for a non-project, return the position of the next headline to search

(defun lh/keep-projects ()
  (save-restriction
    (widen)
    (if (bh/is-project-subtree-p)
        (save-excursion (or (outline-next-heading) (point-max)))
      nil)))
#+end_src
** New plan

A: today
B: This week
C: This month
D: This quarter
E: This half-year
F: This Year
G: The next two years
H: The next five years
I: ten
J: twenty
K: life

#+header: :tangle yes
#+begin_src emacs-lisp

(setq org-default-priority ?B)
(setq org-lowest-priority ?K)
(setq org-highest-priority ?A)

#+end_src
** Links

#+header: :tangle yes
#+begin_src emacs-lisp

(setq org-return-follows-link t)

#+end_src
** save buffers

#+header: :tangle yes
#+begin_src emacs-lisp

(defun l-org-save-all-code-buffers ()
  "Save all code buffers without user confirmation."
  (interactive)
  (save-some-buffers t)
  (when (featurep 'org-id) (org-id-locations-save)))

(if (version< emacs-version "27")
    (add-hook 'focus-out-hook 'l-org-save-all-code-buffers)
  (setq after-focus-change-function 'l-org-save-all-code-buffers))

(run-with-timer 10 10 #'l-org-save-all-code-buffers)
#+end_src
